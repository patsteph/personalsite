#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

/**
 * Generate runtime configuration file with environment variables
 * This runs during the build process to create a runtime-config.js 
 * with the Firebase credentials and site configuration
 */

// Function to load basePath from env files, matching the approach in next.config.js
const loadEnvConfig = () => {
  // First try production env
  let basePath = '';
  if (fs.existsSync(path.resolve(process.cwd(), '.env.production'))) {
    const envFile = fs.readFileSync(path.resolve(process.cwd(), '.env.production'), 'utf8');
    const match = envFile.match(/NEXT_PUBLIC_BASE_PATH=(.+)/);
    if (match && match[1]) {
      basePath = match[1].trim();
    }
  }
  
  // Then check .env.local which might override production env
  if (fs.existsSync(path.resolve(process.cwd(), '.env.local'))) {
    const envFile = fs.readFileSync(path.resolve(process.cwd(), '.env.local'), 'utf8');
    const match = envFile.match(/NEXT_PUBLIC_BASE_PATH=(.+)/);
    if (match && match[1]) {
      basePath = match[1].trim();
    }
  }
  
  return basePath;
};

// Load environment variables from .env.production and .env.local
const productionEnv = dotenv.config({ path: '.env.production' }).parsed || {};
const localEnv = dotenv.config({ path: '.env.local', override: true }).parsed || {};

// Combine them, with local taking precedence
const envVars = { ...productionEnv, ...localEnv };

// Filter only the Firebase related environment variables (those starting with NEXT_PUBLIC_FIREBASE)
const firebaseEnvVars = Object.keys(envVars)
  .filter(key => key.startsWith('NEXT_PUBLIC_FIREBASE'))
  .reduce((obj, key) => {
    obj[key] = envVars[key];
    return obj;
  }, {});

// Determine the environment and basePath consistently with next.config.js
const NODE_ENV = process.env.NODE_ENV || 'development';
const isProduction = NODE_ENV === 'production';

// Get basePath - no longer using /personalsite path prefix
// For standard hosting, we explicitly use empty basePath in production
const basePath = isProduction ? '' : (process.env.NEXT_PUBLIC_BASE_PATH || loadEnvConfig() || '');

console.log(`Runtime config using NODE_ENV: ${NODE_ENV}`);
console.log(`Runtime config using basePath: "${basePath}" in ${isProduction ? 'production' : 'development'} mode`);

// Create the runtime config content - GitHub Pages specific code removed
// Note: We'll only include non-sensitive values, the actual Firebase config will be loaded from env vars
const configContent = `
// This file is generated at build time by generate-runtime-config.js
// Do not edit this file manually
window.runtimeConfig = {
  firebase: {
    // The actual Firebase config is set using environment variables during build and deploy
    // We only include the projectId in the public files for reference
    projectId: "${firebaseEnvVars.NEXT_PUBLIC_FIREBASE_PROJECT_ID || ''}"
  },
  isProduction: ${isProduction},
  basePath: "${basePath}"
};

// Base path detection (no longer needed for non-GitHub Pages hosting)
(function detectBasePath() {
  // Log for debugging purposes
  console.log('Using basePath:', window.runtimeConfig.basePath);
})();

// Asset loading fix no longer needed since we're not using GitHub Pages
`;

// Ensure the public directory exists
const publicDir = path.join(process.cwd(), 'public');
if (!fs.existsSync(publicDir)) {
  fs.mkdirSync(publicDir, { recursive: true });
}

// Write the config to the public directory
const configPath = path.join(publicDir, 'runtime-config.js');
fs.writeFileSync(configPath, configContent);
console.log(`Runtime config written to ${configPath}`);

// Add config to the personalsite directory (needed for Vercel deployment)
const personalSiteDir = path.join(publicDir, 'personalsite');
if (!fs.existsSync(personalSiteDir)) {
  fs.mkdirSync(personalSiteDir, { recursive: true });
}
const personalSiteConfigPath = path.join(personalSiteDir, 'runtime-config.js');
fs.writeFileSync(personalSiteConfigPath, configContent);
console.log(`Runtime config copied to ${personalSiteConfigPath}`);

// Check if 'out' directory exists (for static export), and copy the config there as well
const outDir = path.join(process.cwd(), 'out');
if (fs.existsSync(outDir)) {
  const outConfigPath = path.join(outDir, 'runtime-config.js');
  fs.copyFileSync(configPath, outConfigPath);
  console.log(`Runtime config copied to ${outConfigPath}`);
  
  // Also add to out/personalsite directory
  const outPersonalSiteDir = path.join(outDir, 'personalsite');
  if (!fs.existsSync(outPersonalSiteDir)) {
    fs.mkdirSync(outPersonalSiteDir, { recursive: true });
  }
  const outPersonalSiteConfigPath = path.join(outPersonalSiteDir, 'runtime-config.js');
  fs.writeFileSync(outPersonalSiteConfigPath, configContent);
  console.log(`Runtime config copied to ${outPersonalSiteConfigPath}`);
}
